{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$comment": "Implementation plan for Forward Integration on Resume feature",
  "name": "Forward Integration on Resume (FI-on-Resume)",
  "description": "When a paused plan is resumed, ensure that root nodes pick up the latest target branch state, preventing stale worktrees when the target branch has advanced during the pause period.",
  "version": "0.8.0",
  "feature_branch": "users/jstatia/0.8.0",
  "created": "2026-02-09",

  "motivation": {
    "problem": "Plans created with startPaused=true may sit paused while the target branch receives new commits. When resumed, root nodes resolve their base from plan.baseBranch (a branch name), which naturally picks up the latest ref. However, if the plan was previously running and then paused mid-execution, already-created worktrees are based on stale commits.",
    "scenarios": [
      {
        "id": "S1",
        "name": "Fresh paused plan",
        "description": "Plan created paused, target branch advances, then resumed. Root nodes haven't started yet, so worktrees are created fresh from the latest branch ref. Works correctly today but only if git fetch has been run.",
        "risk": "low",
        "current_behavior": "Mostly works - branch name resolves at worktree creation time. But local refs may be stale without a fetch."
      },
      {
        "id": "S2",
        "name": "Paused mid-execution, pending root nodes",
        "description": "Plan paused after some nodes complete. Remaining root nodes (no dependencies) haven't started. On resume, their worktrees are created from plan.baseBranch which resolves to current ref.",
        "risk": "low",
        "current_behavior": "Same as S1 - works if refs are fresh."
      },
      {
        "id": "S3",
        "name": "Retry after target branch moved",
        "description": "A node failed, plan paused for investigation. Target branch gets new commits. User retries the failed node. Existing worktree is reused (stale base), or if clearWorktree=true, new worktree created from plan.baseBranch (fresh ref if fetched).",
        "risk": "medium",
        "current_behavior": "Without fetch, even clearWorktree=true may resolve to stale local ref."
      }
    ]
  },

  "design": {
    "approach": "Phased implementation with minimal disruption to existing flow",
    "phases": [
      {
        "id": "P1",
        "name": "Fetch on Resume",
        "description": "Add git fetch to resume() to ensure local refs are up-to-date before scheduling resumes.",
        "priority": "high",
        "files": ["src/plan/runner.ts"],
        "changes": [
          {
            "location": "runner.ts → resume()",
            "description": "Before clearing isPaused and starting the pump, run git fetch --all on plan.repoPath. Make resume() async. Log fetch results.",
            "details": [
              "Change resume(planId: string): boolean → resume(planId: string): Promise<boolean>",
              "Add: await git.executor.run(plan.repoPath, ['fetch', '--all', '--prune'])",
              "Log: 'Fetched latest refs for plan {planId} before resuming'",
              "Handle fetch failures gracefully - log warning but still resume",
              "Update all callers of resume() to await the result"
            ]
          }
        ],
        "callers_to_update": [
          "src/mcp/handlers/planHandlers.ts → handleResumePlan()",
          "src/mcp/handlers/planHandlers.ts → handleRetryPlan() (calls resume after retry)",
          "src/mcp/handlers/planHandlers.ts → handleRetryPlanNode() (calls resume after retry)",
          "src/commands/mcpCommands.ts → resume command handler (if exists)"
        ]
      },
      {
        "id": "P2",
        "name": "Fetch on Retry",
        "description": "When retrying a failed node, optionally fetch before re-executing to ensure the latest base is available.",
        "priority": "medium",
        "files": ["src/plan/runner.ts"],
        "changes": [
          {
            "location": "runner.ts → retryNode()",
            "description": "When clearWorktree=true is specified on retry, also fetch first so the new worktree gets the latest base ref.",
            "details": [
              "In retryNode(), if clearWorktree is true, run git fetch before resetting",
              "This ensures that when the worktree is recreated in executeJobNode(), the baseBranch ref is current"
            ]
          }
        ]
      },
      {
        "id": "P3",
        "name": "FI Freshness Check (Future)",
        "description": "Before executing a root node's work, optionally check if the worktree base is stale relative to the target branch and merge in latest changes.",
        "priority": "low",
        "files": ["src/plan/runner.ts"],
        "changes": [
          {
            "location": "runner.ts → executeJobNode() FI section",
            "description": "For root nodes (no dependencies), after worktree creation, compare worktree HEAD against latest target branch ref. If behind, merge target branch into worktree before running work.",
            "details": [
              "Only for root nodes (nodes with no dependency commits)",
              "Compare: git merge-base --is-ancestor <worktree-HEAD> <target-branch>",
              "If worktree is behind: git merge <target-branch> --no-edit in worktree",
              "Log the FI merge in merge-fi phase",
              "This is an enhancement for long-running plans where nodes may start much later than planned"
            ]
          }
        ],
        "considerations": [
          "Merge conflicts in automatic FI could block execution - need fallback strategy",
          "Performance: extra git operations per root node",
          "May not be needed if P1 (fetch on resume) handles 99% of cases"
        ]
      }
    ]
  },

  "testing": {
    "unit_tests": [
      "resume() performs git fetch before unpausing",
      "resume() handles fetch failure gracefully (still resumes)",
      "retryNode() with clearWorktree=true fetches before reset",
      "All callers of resume() handle async correctly"
    ],
    "integration_tests": [
      "Create paused plan, advance target branch, resume - root nodes get latest",
      "Fail a node, advance target branch, retry with clearWorktree=true - worktree gets latest"
    ]
  },

  "validation_schema_fixes": {
    "description": "Pre-requisite: validation schemas in src/mcp/validation/schemas.ts were missing properties that were defined in tool descriptions but not in AJV schemas. Fixed by adding: startPaused to create schemas, newWork/newPrechecks/newPostchecks/clearWorktree/nodeIds to retry schemas.",
    "status": "completed",
    "commit": "pending"
  }
}

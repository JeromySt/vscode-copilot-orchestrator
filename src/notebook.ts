
import * as vscode from 'vscode';
import { TaskRunner } from './taskRunner';
import { JobRunner } from './jobRunner';
export class OrchestratorNotebookSerializer implements vscode.NotebookSerializer { async deserializeNotebook(content:Uint8Array,_t:vscode.CancellationToken){ let data:any={}; try{ data=JSON.parse(Buffer.from(content).toString('utf8')||'{}'); }catch{} const cells=(data.cells||[]).map((c:any)=> new vscode.NotebookCellData(c.kind===2? vscode.NotebookCellKind.Markup: vscode.NotebookCellKind.Code, c.value||'', c.lang||'orchestrator')); return new vscode.NotebookData(cells);} async serializeNotebook(data:vscode.NotebookData,_t:vscode.CancellationToken){ const cells=data.cells.map(c=>({kind: c.kind===vscode.NotebookCellKind.Markup?2:1, value:c.value, lang:c.languageId})); return Buffer.from(JSON.stringify({cells},null,2),'utf8'); } }
export function registerNotebookController(context:vscode.ExtensionContext, runner: JobRunner){ const ctrl = vscode.notebooks.createNotebookController('orchestrator-notebook-controller','orchestrator-notebook','Orchestrator'); ctrl.supportsExecutionOrder=true; ctrl.executeHandler = async (cells)=>{ for (const cell of cells){ const exec = ctrl.createNotebookCellExecution(cell); exec.start(Date.now()); try { const code = cell.document.getText().trim(); if (cell.document.languageId==='shell'){ const rc = await TaskRunner.runShell('orchestrator cell', code, vscode.workspace.workspaceFolders?.[0]?.uri.fsPath); exec.replaceOutput([new vscode.NotebookCellOutput([vscode.NotebookCellOutputItem.text(`exit ${rc}`)])]); } else { const spec = JSON.parse(code); runner.enqueue(spec); exec.replaceOutput([new vscode.NotebookCellOutput([vscode.NotebookCellOutputItem.text(`job ${spec.id} queued`)])]); } exec.end(true, Date.now()); } catch(e:any){ exec.replaceOutput([new vscode.NotebookCellOutput([vscode.NotebookCellOutputItem.text(String(e))])]); exec.end(false, Date.now()); } } }; context.subscriptions.push(ctrl); }
